# mk-api

[Document](http://mk-api.pages.oa.com/)

码客前端 API 接口封装

## Usage

**开发环境**
`tnpm install @tencent/mk-api@beta`
**体验环境**
`tnpm install @tencent/mk-api@next`
**生成环境**
`tnpm install @tencent/mk-api@latest`

### 初始化

默认会使用`axios`作为请求库

```ts
// axios default config
export const BaseAxiosConfig: Pick<
  AxiosRequestConfig,
  'timeout' | 'withCredentials' | 'paramsSerializer'
> = {
  timeout: 1000 * 12,
  withCredentials: true, // 允许携带cookie
  paramsSerializer: (params) => {
    return qs.stringify(params, {
      encode: true,
      // encodeValuesOnly: false,
      arrayFormat: 'brackets',
    });
  },
};
```

```js
import { init } from '@tencent/mk-api';
init({
  API_BASE: '', // 默认后端api地址
  UPLOAD_BASE: '', // 上传的路径, 可以是绝对地址或者相对地址
  DEFAULT_PAGE_NO: 0, // 默认分页offset
  DEFAULT_PAGE_SIZE: 20, // 默认分页limit,
  http: {}, // AxiosLike, 后面讲
  throwResInError: true, // 是否在默认axios实例中拦截error, 并且抛出response, default: true
  // ...axiosConfig, 剩下的所有配置将传递给axios
});
```

### 调用 api

为了达到按需加载, 目前是通过分组形式组织 api, 需要`import`相应分组后调用相关 api

- MkCoterieApi 圈子相关 api
- MkMessageApi 消息相关 api
- MkHomeApi 首页相关 api
- MkUserApi 用户相关 api
- MkQuestionApi 问答相关 api
- MkAnswerApi 回答相关 api
- MkAnswerNoteApi 回答评论相关 api
- MkBannerApi banner 相关 api
- MkBadgeApi 徽章相关 api
- MkProjectsApi 项目项目 api
- MkRankApi 码力值相关 api
- MkSearchApi 搜索相关 api
- MkTagApi 标签相关 api
- MkToolApi 工具类 api, 包括上传, markdown preview
- MkTopicApi 专题相关 api
- MkExpertApi 向专家提问相关 api
- MkRedpacketApi 红包 api
- MkAdditionApi 追问 api
- MkIdeaApi 想法 api
- MkTemplateApi 圈子模板相关 api
- MkMagazineApi 活动评论相关 api

```js
// import进对应的Api
import { MkCoterieApi } from '@tencent/mk-api';
```

### 如何获得 Http 请求示例

```js
import { Http, setHttp } from '@tencent/mk-api';
```

- Http: 为实际发起请求的对象, 默认为`axios`实例, 也可以自定义. 只可以从`Http.ins`拿到实际的实例
- setHttp: 自定义请求对象, 要求其为一个`AxiosLike`对象

即只需要实现以下方法, 并且调用形式与`axios`对应方法一致即可

```ts
export type AxiosLike =
  | AxiosInstance
  | Pick<
      AxiosInstance,
      'request' | 'get' | 'patch' | 'post' | 'put' | 'delete'
    >;
```

**Example**

```js
import { Http, setHttp } from '@tencent/mk-api';
import axios from 'axios';
// 自定义Http
const CustomHttp = {
  get(url) {},
  post(url, body, config) {},
  // ... put, patch, delete, request
};
setHttp(CustomHttp);
Http.ins === CustomHttp; // true
Http === CustomHttp; // false

// 自定义axios实例
const axiosIns = axios.create();
setHttp(axiosIns);
```

也可以在`init`时候传入

```js
import { init } from '@tencent/mk-api';
// 自定义Http
const CustomHttp = {
  get(url) {},
  post(url, body, config) {},
  // ... put, patch, delete, request
};
init({
  http: CustomHttp,
});
```

### 如何扩展 axios

默认请求实例为`axios`实例, 因此可以通过`Http.ins`调用`axios`任何方法

```js
import { Http } from '@tencent/mk-api';
const { ins } = Http;
ins.interceptors.request.use();
// 默认抛出error.response
// 如果需要关闭, 请在config中设置throwResInError=false
ins.interceptors.response.use();
```

### 如何修改某次请求的配置

`APIGroup.api.config(InjectConfig).run(...args)`

调用具体`api`下的`config`方法, 传入配置或者回调函数, 然后**同步**执行`run`方法

```ts
type InjectConfig =
  | AxiosRequestConfig
  | ((config: AxiosRequestConfig) => AxiosRequestConfig)
  | null;
```

**Note**

这里一定要同步执行`run`, 不能异步

```ts
// Error
const c = APIGroup.api.config();
await Promise.resolve();
c.run();
```

**Example**

```ts
import { MkUserApi } from '@tencent/mk-api';
MkUserApi.get
  // 传递字面变量时候, headers以及params会合并到原接口上
  .config({
    params: {
      user: 123,
    },
  })
  // 同步调用
  .run();
  
MkUserApi.get
  // 传递回调, 会直接将返回结果作为本次请求的config, 也就是会覆盖原接口上的params和headers
  .config(config => {})
  // 同步调用
  .run();
```

## Develop

### 目录

api 定义统一放在`src/api`下

同一类型 api 在新目录下完成

- `index.ts` 编写 api 定义
- `types.ts` 编写 Types 类型

### 模型声明

自动格式化成实际所需要的字段信息

基础的`Types`在`src/define/base`下

- NumberDTO: 代表了 number 属性
- StringDTO: 代表了 string 属性
- BooleanDTO: 代表了 boolean 属性
- AnyDTO: 代表了 any 属性
- BaseUser, BaseTime, Rootable, Linkable, Agree, DisAgree, Content, KV 分别是基础 Types, 可以通过`Extends`方法继承

> Extends 方法其实就是 Object.assign 封装, 并且扩展了类型声明, 也可以通过 pick, omit, constant, union 等方法组织模型

**Example**

```ts
import { Extends, BaseUser } from 'src/define/base';
export const Model = Extends(
  {
    id: NumberDTO,
  },
  BaseUser,
); // 此处ts会自动完成类型推断
Model.id; // number
Model.userId; // number
Model.username; // string
const ModelHttp = TypeWrapper(Model); // 返还Promise<AxiosResponse<Model>>
```

### TypeHTTP 封装 types 的 http 请求实例

使用`TypeWrapper`来封装`http`信息, 并且调用其返还的`get`, `post`等方法完成请求, 会自动完成类型推断

**Example**

```ts
import { Http, TypeWrapper } from 'src/http';
import { StrOrNum } from 'src/types';
import { ModelHttp } from './types';

ModelHttp.get().then((d) => {
  d.data.id; // number
  d.data.userId; // number
});

// DTOHttp可以复用, 同一个DTOHttp下各个方法返回类型一致, 也可以自定义返还类型, 但是确保返还类型正确, 因为DTO已经初始化了
ModelHttp.delete<null>();

// 如果返回的数据是数组, 则先调用list后调用请求方法
ModelHttp.list()
  .get()
  .then((d) => {
    d.data[0].id; // number
    d.data[0].userId; // number
  });
// 也可以自定义list的返回类型, 但是传给后端的dto不变
ModelHttp.list<{ id: number; username: string }>()
  .get()
  .then((d) => {
    d.data[0].id; // number
    d.data[0].username; // string
  });
```

### 参数声明

- 如果参数是在`path`上, 则使用平铺形式声明, 且按顺序声明
- 如果参数是在`body`或者`query`上, 则使用`obj`形式统一在最后一个参数声明

**Exmaple: 参数声明**

```ts
export const MkExampleApi = {
  search(arg1, arg2, { arg3, arg4 }: { arg3: any; arg4: any }) {
    return Http.post(
      `/path/to/${arg1}/${arg2}`,
      {
        arg3,
      },
      {
        params: {
          arg4,
        },
      },
    );
  },
};
```

### 分页处理

目前分页方式统一使用`limit`+`offset`

```ts
export interface PaginationParams {
  offset?: number;
  limit?: number;
}
```

**Example: 设置默认参数**

```js
import { Http } from '../http';
import { injectDefaultParams } from '../base';
export const MkExampleApi = {
  example(params?: AnyParams & PaginationParams) {
    Http.get('', {
      params: injectDefaultParams(params), // 会自动注入默认的分页参数
    });
  },
};
```

### 注释

采用`jsdoc`格式声明注释

## Build

```bash
tnpm run build
```

并修改`CHANGELOG`, 添加对应版本说明

**Example**

```markdown
## Release(beat) x.x.x

### Features/Bugfix/Breaking

#### ApiType

- ApiFeature
```

## Test

> 如果开启了代理, 需要将`http://example.com`加入到`no_proxy`中
> 例如:`export no_proxy=${no_proxy},http://example.com`

测试主要确保`api`调用路由和传递参数正确, 因此所有`api`都由`nock`拦截

提供测试方法

- matchStatus: 用来判断`api`调用返回`http code`是否为`200`
- testWithDefaultPagination: 用来测试带`pagination`的`api`, 会自动带入默认分页参数进行测试

## Publish

### Release Beta

`npm run release-beta`

发布`Beta`版本

在上一个`beta`以及`next`中选择最大的版本, 执行`patch`操作

**例如**

betaVersion=2.14.1 nextVersion=2.14-next.0 --> beta: 2.14.2
betaVersion=2.13.9 nextVersion=2.14-next.0 --> beta: 2.14.1

### Release Test

`npm run release-test`

发布`Test`版本

在上一个`beta`以及`test`中选择最大的版本, 执行`preminor` 或则 `prerelease&&perid=test`操作

**例如**
betaVersion=2.14.9 testVersion=2.14.0-test.19 --> test:2.15.0-test.0 (preminor)
betaVersion=2.14.9 testVersion=2.15.0-test.0 --> test: 2.14.0-test.1 (prerelease)

### Release Next

`npm run release-next`

发布`Next`版本

在上一个`next`以及`test`中选择最大的版本, 执行`prerelease`操作

**例如**
testVersion=2.14.0-test.19 nextVersion=2.13.0-next.20 --> next: 2.14.0-next.0
testVersion=2.14.0-test.19 nextVersion-2.14.0-next.2 --> next: 2.14.0-next.3

### Release Latest

`npm run release-latest`

发布`latest`版本

直接执行`minor`操作

**例如**
2.14.0 -> 2.15.0

### Release Latest Hotfix

`npm run release-hotfix`

在`latest`基础上执行`prerelease&&preid=hotfix`

**例如**

2.14.0 -> 2.14.0-hotfix.0
2.14.0-hotfix.0 -> 2.14.0-hotfix.1
