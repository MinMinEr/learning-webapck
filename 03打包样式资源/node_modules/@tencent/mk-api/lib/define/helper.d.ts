import { PlainObj, StrOrNum } from '../types';
import { Override, Override1, Override2, Override3, Override4, Override5, Override6 } from './override';
/**
 * 实际执行的是Object.assign
 * 主要用于typescript的类型声明
 * 返回值声明用最原始的
 * @export
 * @template T0
 * @template T1
 * @param {T0} t
 * @param {T1} u
 * @returns
 */
export declare function extend<T0, T1>(t: T0, u: T1): {
    [P in keyof (T0 & T1)]: Override<P, T0, T1>;
};
export declare function extend<T0 extends Record<string, any>, T1, T2>(t: T0, u: T1, z: T2): {
    [P in keyof (T0 & T1 & T2)]: Override1<P, T0, T1, T2>;
};
export declare function extend<T0 extends Record<string, any>, T1, T2, T3>(t: T0, u: T1, z: T2, y: T3): {
    [P in keyof (T0 & T1 & T2 & T3)]: Override2<P, T0, T1, T2, T3>;
};
export declare function extend<T0 extends Record<string, any>, T1, T2, T3, T4>(t: T0, u: T1, z: T2, y: T3, m: T4): {
    [P in keyof (T0 & T1 & T2 & T3 & T4)]: Override3<P, T0, T1, T2, T3, T4>;
};
export declare function extend<T0 extends Record<string, any>, T1, T2, T3, T4, T5>(t: T0, u: T1, z: T2, y: T3, m: T4, n: T5): {
    [P in keyof (T0 & T1 & T2 & T3 & T4 & T5)]: Override4<P, T0, T1, T2, T3, T4, T5>;
};
export declare function extend<T0 extends Record<string, any>, T1, T2, T3, T4, T5, T6>(t: T0, u: T1, z: T2, y: T3, m: T4, n: T5, b: T6): {
    [P in keyof (T0 & T1 & T2 & T3 & T4 & T5 & T6)]: Override5<P, T0, T1, T2, T3, T4, T5, T6>;
};
export declare function extend<T0 extends Record<string, any>, T1, T2, T3, T4, T5, T6, T7>(t: T0, u: T1, z: T2, y: T3, m: T4, n: T5, b: T6, t7: T7): {
    [P in keyof (T0 & T1 & T2 & T3 & T4 & T5 & T6 & T7)]: Override6<P, T0, T1, T2, T3, T4, T5, T6, T7>;
};
/**
 * 将对象类型改成可选, 无实际用处, 用于类型推导
 *
 * @export
 * @template T
 * @param {T} arg
 * @returns {Partial<T>}
 */
export declare function optional<T>(arg: T): {
    [P in keyof T]?: T[P];
};
/**
 * 从对象中选择其中某几个属性
 * 这里的返回值声明不需要改, 主要是为了类型推导, 实际等同Pick
 * @export
 * @template T
 * @template K
 * @param {T} arg
 * @param {K[]} [keys]
 * @returns {Pick<T, K>}
 */
export declare function pick<T extends PlainObj, K extends keyof T>(arg: T, keys?: K[]): {
    [P in K]: T[P];
};
/**
 * 从对象中剔除某几个属性
 * 这里的返回值声明不需要改, 主要是为了类型推导, 实际等同Pick
 * @export
 * @template T
 * @template K
 * @param {T} arg
 * @param {K[]} [keys]
 * @returns {Omit<T, K>}
 */
export declare function omit<T, K extends keyof T>(arg: T, keys?: K[]): {
    [P in Exclude<keyof T, K>]: T[P];
};
/**
 * 用于类型推导, 将类型转成常量
 * 无实际用处
 */
/**
 * @export
 * @template T
 * @param {T[]} arg
 * @returns {typeof arg[number]}
 */
export declare function constant<T extends StrOrNum>(...arg: T[]): typeof arg[number];
/**
 * 用于类型推导, 将多数类型组合成联合类型
 * 无实际用处
 *
 * @export
 * @template T
 * @param {...T} arg
 * @returns {typeof arg[number]}
 */
export declare function union<T extends Array<any>>(...arg: T): typeof arg[number];
